{% extends "layout.html" %}
{% block title %}How It Works - Project Flowchart{% endblock %}

{% block head %}
    <!-- Specific styles for the flowchart -->
    <style>
        .flowchart-node {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .flowchart-node:hover {
            transform: translateY(-5px) scale(1.03);
            box-shadow: 0 10px 20px rgba(0,0,0,0.15), 0 3px 6px rgba(0,0,0,0.10);
        }
        .description-item {
            display: none;
            transition: opacity 0.5s ease;
        }
        .description-item.active {
            display: block;
        }
        .arrow {
            transition: all 0.3s ease;
        }
        .highlight-arrow {
            stroke: #2563eb; /* blue-600 */
        }
        .highlight-node {
             border-color: #2563eb;
             box-shadow: 0 0 15px rgba(37, 99, 235, 0.5);
        }
    </style>
{% endblock %}

{% block content %}
    <div class="text-center mb-12">
        <h1 class="text-4xl font-bold text-gray-900">Project Workflow</h1>
        <p class="mt-2 text-lg text-gray-600">Hover over any step to see a detailed explanation of how our app works.</p>
    </div>

    <div class="relative bg-white p-8 rounded-2xl shadow-lg">
        <!-- SVG Container for Arrows -->
        <svg id="arrow-svg" class="absolute top-0 left-0 w-full h-full" style="pointer-events: none;"></svg>

        <!-- Flowchart Columns (copied from your original file) -->
        <div class="grid grid-cols-1 md:grid-cols-4 gap-8 text-center">
            <div class="space-y-20">
                <h2 class="text-xl font-semibold text-blue-700 bg-blue-100 py-2 px-4 rounded-lg">1. User Interface (Browser)</h2>
                <div id="node-start" class="flowchart-node bg-white p-4 rounded-xl shadow-md border-2 border-transparent">
                    <h3 class="font-semibold">Start</h3>
                    <p class="text-sm text-gray-500">User opens the web page.</p>
                </div>
                <div id="node-upload" class="flowchart-node bg-white p-4 rounded-xl shadow-md border-2 border-transparent">
                    <h3 class="font-semibold">Upload Image & Name</h3>
                    <p class="text-sm text-gray-500">User fills form and clicks "Analyze Tea".</p>
                </div>
                 <div id="node-display" class="flowchart-node bg-white p-4 rounded-xl shadow-md border-2 border-transparent">
                    <h3 class="font-semibold">Display Results</h3>
                    <p class="text-sm text-gray-500">Shows analysis and updated leaderboard.</p>
                </div>
            </div>
            <div class="space-y-20">
                <h2 class="text-xl font-semibold text-green-700 bg-green-100 py-2 px-4 rounded-lg">2. Flask Server (app.py)</h2>
                <div id="node-receive" class="flowchart-node bg-white p-4 rounded-xl shadow-md border-2 border-transparent">
                    <h3 class="font-semibold">Receive Request</h3>
                    <p class="text-sm text-gray-500">Saves image and prepares to process.</p>
                </div>
                <div id="node-call-analyzer" class="flowchart-node bg-white p-4 rounded-xl shadow-md border-2 border-transparent">
                    <h3 class="font-semibold">Call Analyzer</h3>
                    <p class="text-sm text-gray-500">Sends image path to the analysis script.</p>
                </div>
                <div id="node-update-db" class="flowchart-node bg-white p-4 rounded-xl shadow-md border-2 border-transparent">
                    <h3 class="font-semibold">Update Database</h3>
                    <p class="text-sm text-gray-500">Saves the final bubble count and name.</p>
                </div>
            </div>
            <div class="space-y-20">
                <h2 class="text-xl font-semibold text-purple-700 bg-purple-100 py-2 px-4 rounded-lg">3. Image Analyzer</h2>
                <div id="node-analyze" class="flowchart-node bg-white p-4 rounded-xl shadow-md border-2 border-transparent">
                    <h3 class="font-semibold">Analyze & Count</h3>
                    <p class="text-sm text-gray-500">Performs computer vision magic.</p>
                </div>
                 <div id="node-return" class="flowchart-node bg-white p-4 rounded-xl shadow-md border-2 border-transparent">
                    <h3 class="font-semibold">Return Results</h3>
                    <p class="text-sm text-gray-500">Sends count and image paths back.</p>
                </div>
            </div>
            <div class="space-y-20">
                 <h2 class="text-xl font-semibold text-yellow-700 bg-yellow-100 py-2 px-4 rounded-lg">4. Database (tea.db)</h2>
                <div id="node-store" class="flowchart-node bg-white p-4 rounded-xl shadow-md border-2 border-transparent">
                    <h3 class="font-semibold">Store Data</h3>
                    <p class="text-sm text-gray-500">Persistently saves leaderboard entries.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Descriptions Section (copied from your original file) -->
    <div id="descriptions" class="mt-12 bg-white p-8 rounded-2xl shadow-lg min-h-[150px]">
         <div id="desc-default" class="description-item active"><h3 class="text-2xl font-bold text-gray-800 mb-2">Project Workflow</h3><p class="text-gray-600">This flowchart visualizes the journey of a user's request, from uploading an image in the browser to the backend processing and final display of results. Hover over any of the steps above to learn more about what happens at each stage.</p></div>
        <div id="desc-start" class="description-item"><h3 class="text-2xl font-bold text-blue-700 mb-2">Step 1: Start</h3><p class="text-gray-600">The process begins when the user navigates to the application's URL in their web browser. The Flask server renders the HTML templates, which displays the main pages of the application.</p></div>
        <div id="desc-upload" class="description-item"><h3 class="text-2xl font-bold text-blue-700 mb-2">Step 2: Upload Image & Name</h3><p class="text-gray-600">The user interacts with the form on the 'Analyze' page, entering their name and selecting an image file. Clicking "Count The Bubbles" sends this data in an HTTP POST request to the Flask server.</p></div>
        <div id="desc-receive" class="description-item"><h3 class="text-2xl font-bold text-green-700 mb-2">Step 3: Receive Request</h3><p class="text-gray-600">The Flask server (`app.py`) receives the POST request. It validates the input and saves the uploaded image to the `static/uploads/` directory with a unique filename.</p></div>
        <div id="desc-call-analyzer" class="description-item"><h3 class="text-2xl font-bold text-green-700 mb-2">Step 4: Call Analyzer</h3><p class="text-gray-600">`app.py` calls the `count_bubbles()` function from `bubble_analyzer.py`, passing the path of the newly saved image to delegate the analysis.</p></div>
        <div id="desc-analyze" class="description-item"><h3 class="text-2xl font-bold text-purple-700 mb-2">Step 5: Analyze & Count Bubbles</h3><p class="text-gray-600">The `bubble_analyzer.py` script uses OpenCV to perform image processing: masking, enhancement, filtering, and contour detection to identify and count the bubbles.</p></div>
        <div id="desc-return" class="description-item"><h3 class="text-2xl font-bold text-purple-700 mb-2">Step 6: Return Results</h3><p class="text-gray-600">The `count_bubbles()` function returns the bubble count and the file paths for the generated visualization images back to `app.py`.</p></div>
         <div id="desc-update-db" class="description-item"><h3 class="text-2xl font-bold text-green-700 mb-2">Step 7: Update Database</h3><p class="text-gray-600">The Flask server connects to the SQLite database (`tea.db`) and inserts a new row with the user's name, bubble count, and image paths.</p></div>
         <div id="desc-store" class="description-item"><h3 class="text-2xl font-bold text-yellow-700 mb-2">Step 8: Store Data</h3><p class="text-gray-600">The SQLite database engine writes the new entry to the `tea.db` file, ensuring the data is saved permanently for the leaderboard.</p></div>
         <div id="desc-display" class="description-item"><h3 class="text-2xl font-bold text-blue-700 mb-2">Step 9: Display Results</h3><p class="text-gray-600">Finally, the Flask server re-renders the `analyze.html` template, passing the results directly to it. The template then displays the "Latest Analysis" section with the bubble count and images.</p></div>
    </div>

    <!-- JavaScript for flowchart interactivity -->
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const nodes = document.querySelectorAll('.flowchart-node');
            const descriptionsContainer = document.getElementById('descriptions');
            const defaultDescription = document.getElementById('desc-default');
            const arrowSvg = document.getElementById('arrow-svg');

            // Define connections between nodes
            const connections = [
                { from: 'node-start', to: 'node-upload' },
                { from: 'node-upload', to: 'node-receive' },
                { from: 'node-receive', to: 'node-call-analyzer' },
                { from: 'node-call-analyzer', to: 'node-analyze' },
                { from: 'node-analyze', to: 'node-return' },
                { from: 'node-return', to: 'node-update-db' },
                { from: 'node-update-db', to: 'node-store' },
                { from: 'node-update-db', to: 'node-display' }, // Parallel path
                { from: 'node-store', to: 'node-display' } // Indirect influence/final display
            ];

            function getConnectorPoints(fromNode, toNode) {
                const fromRect = fromNode.getBoundingClientRect();
                const toRect = toNode.getBoundingClientRect();
                const svgRect = arrowSvg.getBoundingClientRect();

                const startX = fromRect.left + fromRect.width / 2 - svgRect.left;
                const startY = fromRect.bottom - svgRect.top;

                const endX = toRect.left + toRect.width / 2 - svgRect.left;
                const endY = toRect.top - svgRect.top;

                return { startX, startY, endX, endY };
            }

            function drawArrow(id, startX, startY, endX, endY) {
                let arrow = document.getElementById(id);
                if (!arrow) {
                    arrow = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    arrow.setAttribute('id', id);
                    arrow.setAttribute('stroke', '#cbd5e1'); // gray-300
                    arrow.setAttribute('stroke-width', '2');
                    arrow.setAttribute('marker-end', 'url(#arrowhead)');
                    arrow.classList.add('arrow');
                    arrowSvg.appendChild(arrow);
                }
                arrow.setAttribute('x1', startX);
                arrow.setAttribute('y1', startY);
                arrow.setAttribute('x2', endX);
                arrow.setAttribute('y2', endY);
            }

            function redrawArrows() {
                arrowSvg.innerHTML = `
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7"
                                refX="0" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#cbd5e1" />
                        </marker>
                        <marker id="arrowhead-highlight" markerWidth="10" markerHeight="7"
                                refX="0" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#2563eb" />
                        </marker>
                    </defs>
                `; // Clear and redraw defs

                connections.forEach((conn, index) => {
                    const fromNode = document.getElementById(conn.from);
                    const toNode = document.getElementById(conn.to);
                    if (fromNode && toNode) {
                        const { startX, startY, endX, endY } = getConnectorPoints(fromNode, toNode);
                        drawArrow(`arrow-${index}`, startX, startY, endX, endY);
                    }
                });
            }

            // Initial drawing of arrows
            redrawArrows();
            window.addEventListener('resize', redrawArrows);

            nodes.forEach(node => {
                node.addEventListener('mouseenter', function () {
                    const nodeId = this.id;
                    const descId = `desc-${nodeId.replace('node-', '')}`;

                    // Hide all descriptions, show default if no specific one
                    document.querySelectorAll('.description-item').forEach(desc => {
                        desc.classList.remove('active');
                    });
                    const targetDesc = document.getElementById(descId);
                    if (targetDesc) {
                        targetDesc.classList.add('active');
                    } else {
                        defaultDescription.classList.add('active');
                    }

                    // Highlight node
                    this.classList.add('highlight-node');

                    // Highlight connected arrows
                    connections.forEach((conn, index) => {
                        const arrow = document.getElementById(`arrow-${index}`);
                        if (arrow) {
                            if (conn.from === nodeId || conn.to === nodeId) {
                                arrow.classList.add('highlight-arrow');
                                arrow.setAttribute('stroke', '#2563eb');
                                arrow.setAttribute('marker-end', 'url(#arrowhead-highlight)');
                            } else {
                                arrow.classList.remove('highlight-arrow');
                                arrow.setAttribute('stroke', '#cbd5e1');
                                arrow.setAttribute('marker-end', 'url(#arrowhead)');
                            }
                        }
                    });
                });

                node.addEventListener('mouseleave', function () {
                    // Hide all descriptions, show default
                    document.querySelectorAll('.description-item').forEach(desc => {
                        desc.classList.remove('active');
                    });
                    defaultDescription.classList.add('active');

                    // Remove highlight from node
                    this.classList.remove('highlight-node');

                    // Remove highlight from all arrows
                    document.querySelectorAll('.arrow').forEach(arrow => {
                        arrow.classList.remove('highlight-arrow');
                        arrow.setAttribute('stroke', '#cbd5e1');
                        arrow.setAttribute('marker-end', 'url(#arrowhead)');
                    });
                });
            });
        });
    </script>
{% endblock %} 